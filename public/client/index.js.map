{
  "version": 3,
  "sources": ["../../src/network/client.ts", "../../src/engine/vibi.ts", "../../src/game/index.ts"],
  "sourcesContent": ["type TimeSync = {\n  clock_offset: number;     // difference between server clock and local clock\n  lowest_ping: number;      // best round-trip time achieved so far\n  request_sent_at: number;  // timestamp when last get_time request was sent\n  last_ping: number;        // most recent measured RTT (ms)\n};\n\nconst time_sync: TimeSync = {\n  clock_offset: Infinity,\n  lowest_ping: Infinity,\n  request_sent_at: 0,\n  last_ping: Infinity,\n};\n\nconst ws = new WebSocket(`ws://${window.location.hostname}:8080`);\n\ntype MessageHandler = (message: any) => void;\nconst room_watchers = new Map<string, MessageHandler>();\n\nlet is_synced = false;\nconst sync_listeners: Array<() => void> = [];\n\nfunction now(): number {\n  return Math.floor(Date.now());\n}\n\nexport function server_time(): number {\n  if (!isFinite(time_sync.clock_offset)) {\n    throw new Error(\"server_time() called before initial sync\");\n  }\n  return Math.floor(now() + time_sync.clock_offset);\n}\n\nfunction ensure_open(): void {\n  if (ws.readyState !== WebSocket.OPEN) {\n    throw new Error(\"WebSocket not open\");\n  }\n}\n\nexport function send(obj: any): void {\n  ensure_open();\n  ws.send(JSON.stringify(obj));\n}\n\nfunction register_handler(room: string, handler?: MessageHandler): void {\n  if (!handler) {\n    return;\n  }\n\n  if (room_watchers.has(room)) {\n    throw new Error(`Handler already registered for room: ${room}`);\n  }\n\n  room_watchers.set(room, handler);\n}\n\nws.addEventListener(\"open\", () => {\n  console.log(\"[WS] Connected\");\n  time_sync.request_sent_at = now();\n  ws.send(JSON.stringify({ $: \"get_time\" }));\n  setInterval(() => {\n    time_sync.request_sent_at = now();\n    ws.send(JSON.stringify({ $: \"get_time\" }));\n  }, 2000);\n});\n\nws.addEventListener(\"message\", (event) => {\n  const msg = JSON.parse(event.data);\n\n  switch (msg.$) {\n    case \"info_time\": {\n      const t    = now();\n      const ping = t - time_sync.request_sent_at;\n\n      time_sync.last_ping = ping;\n\n      if (ping < time_sync.lowest_ping) {\n        const local_avg    = Math.floor((time_sync.request_sent_at + t) / 2);\n        time_sync.clock_offset = msg.time - local_avg;\n        time_sync.lowest_ping  = ping;\n      }\n\n      if (!is_synced) {\n        is_synced = true;\n        for (const cb of sync_listeners) {\n          cb();\n        }\n        sync_listeners.length = 0;\n      }\n      break;\n    }\n\n    case \"info_post\": {\n      const handler = room_watchers.get(msg.room);\n      if (handler) {\n        handler(msg);\n      }\n      break;\n    }\n  }\n});\n\n// API\nexport function gen_name(): string {\n  const alphabet   = \"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-\";\n  const bytes      = new Uint8Array(8);\n  const can_crypto = typeof crypto !== \"undefined\" && typeof crypto.getRandomValues === \"function\";\n\n  if (can_crypto) {\n    crypto.getRandomValues(bytes);\n  } else {\n    for (let i = 0; i < 8; i++) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n  }\n\n  let out = \"\";\n  for (let i = 0; i < 8; i++) {\n    out += alphabet[bytes[i] % 64];\n  }\n\n  return out;\n}\n\nexport function post(room: string, data: any): string {\n  const name = gen_name();\n  send({ $: \"post\", room, time: server_time(), name, data });\n  return name;\n}\n\nexport function load(room: string, from: number = 0, handler?: MessageHandler): void {\n  register_handler(room, handler);\n  send({ $: \"load\", room, from });\n}\n\nexport function watch(room: string, handler?: MessageHandler): void {\n  register_handler(room, handler);\n  send({ $: \"watch\", room });\n}\n\nexport function unwatch(room: string): void {\n  room_watchers.delete(room);\n  send({ $: \"unwatch\", room });\n}\n\nexport function close(): void {\n  ws.close();\n}\n\nexport function on_sync(callback: () => void): void {\n  if (is_synced) {\n    callback();\n    return;\n  }\n  sync_listeners.push(callback);\n}\n\nexport function ping(): number {\n  return time_sync.last_ping;\n}\n", "import * as client from \"../network/client.ts\";\n\ntype Post<P> = {\n  room: string;\n  index: number;\n  server_time: number;\n  client_time: number;\n  name?: string; // unique id for dedup/reindex (optional for legacy)\n  data: P;\n};\n\nexport class Vibi<S, P> {\n  room:        string;\n  init:        S;\n  on_tick:     (state: S) => S;\n  on_post:     (post: P, state: S) => S;\n  smooth:      (past: S, curr: S) => S;\n  tick_rate:   number;\n  tolerance:   number;\n  room_posts:  Map<number, Post<P>>;\n  local_posts: Map<string, Post<P>>; // predicted local posts keyed by name\n  state_cache: S[];                  // cached states keyed by tick offset\n  cache_start: number | null;        // tick corresponding to state_cache[0]\n  timeline:    Map<number, Post<P>[]> | null; // cached timeline of posts per tick\n\n  // Compute the authoritative time a post takes effect.\n  private official_time(post: Post<P>): number {\n    if (post.client_time <= post.server_time - this.tolerance) {\n      return post.server_time - this.tolerance;\n    } else {\n      return post.client_time;\n    }\n  }\n\n  // Convert a post into its authoritative tick.\n  private official_tick(post: Post<P>): number {\n    return this.time_to_tick(this.official_time(post));\n  }\n\n  // Reset all cached states.\n  private reset_cache(): void {\n    this.state_cache.length = 0;\n    this.cache_start = null;\n  }\n\n  // Drop cached states from the provided tick (inclusive) onward.\n  private invalidate_cache(from_tick: number): void {\n    this.invalidate_timeline();\n\n    if (this.cache_start === null) {\n      return;\n    }\n\n    const drop_from = from_tick - this.cache_start;\n    if (drop_from <= 0) {\n      this.reset_cache();\n      return;\n    }\n\n    if (drop_from < this.state_cache.length) {\n      this.state_cache.length = drop_from;\n    }\n  }\n\n  // Invalidate the cached timeline so it will be rebuilt lazily.\n  private invalidate_timeline(): void {\n    this.timeline = null;\n  }\n\n  constructor(\n    room:      string,\n    init:      S,\n    on_tick:   (state: S) => S,\n    on_post:   (post: P, state: S) => S,\n    smooth:    (past: S, curr: S) => S,\n    tick_rate: number,\n    tolerance: number\n  ) {\n    this.room        = room;\n    this.init        = init;\n    this.on_tick     = on_tick;\n    this.on_post     = on_post;\n    this.smooth      = smooth;\n    this.tick_rate   = tick_rate;\n    this.tolerance   = tolerance;\n    this.room_posts  = new Map();\n    this.local_posts = new Map();\n    this.state_cache = [];\n    this.cache_start = null;\n    this.timeline    = null;\n\n    // Wait for initial time sync before interacting with server\n    client.on_sync(() => {\n      console.log(`[VIBI] synced; watching+loading room=${this.room}`);\n      // Watch the room with callback\n      client.watch(this.room, (post) => {\n        const official_tick = this.official_tick(post);\n\n        // If this official post matches a local predicted one, drop the local copy\n        if (post.name && this.local_posts.has(post.name)) {\n          this.local_posts.delete(post.name);\n        }\n        this.room_posts.set(post.index, post);\n        this.invalidate_cache(official_tick);\n      });\n\n      // Load all existing posts\n      client.load(this.room, 0);\n    });\n  }\n\n  // No extra helpers needed with local_posts: simplicity preserved\n\n  time_to_tick(server_time: number): number {\n    return Math.floor((server_time * this.tick_rate) / 1000);\n  }\n\n  server_time(): number {\n    return client.server_time();\n  }\n\n  server_tick(): number {\n    return this.time_to_tick(this.server_time());\n  }\n\n  // Total official posts loaded for this room\n  post_count(): number {\n    return this.room_posts.size;\n  }\n\n  // Compute a render-ready state by blending authoritative past and current\n  // using the provided smooth(past, curr) function.\n  compute_render_state(): S {\n    const curr_tick  = this.server_tick();\n    const tick_ms    = 1000 / this.tick_rate;\n    const tol_ticks  = Math.ceil(this.tolerance / tick_ms);\n    const rtt_ms     = client.ping();\n    const half_rtt   = isFinite(rtt_ms) ? Math.ceil((rtt_ms / 2) / tick_ms) : 0;\n    const past_ticks = Math.max(tol_ticks, half_rtt + 1);\n    const past_tick  = Math.max(0, curr_tick - past_ticks);\n\n    const past_state = this.compute_state_at(past_tick);\n    const curr_state = this.compute_state_at(curr_tick);\n\n    return this.smooth(past_state, curr_state);\n  }\n\n  initial_time(): number | null {\n    const post = this.room_posts.get(0);\n    if (!post) {\n      return null;\n    }\n    return this.official_time(post);\n  }\n\n  initial_tick(): number | null {\n    const t = this.initial_time();\n    if (t === null) {\n      return null;\n    }\n    return this.time_to_tick(t);\n  }\n\n  private build_timeline(): Map<number, Post<P>[]> {\n    if (this.timeline) {\n      return this.timeline;\n    }\n\n    const timeline = new Map<number, Post<P>[]>();\n\n    for (const post of this.room_posts.values()) {\n      const official_tick = this.official_tick(post);\n      if (!timeline.has(official_tick)) {\n        timeline.set(official_tick, []);\n      }\n      timeline.get(official_tick)!.push(post);\n    }\n\n    for (const post of this.local_posts.values()) {\n      const official_tick = this.official_tick(post);\n      if (!timeline.has(official_tick)) {\n        timeline.set(official_tick, []);\n      }\n      const local_queued: Post<P> = { ...post, index: Number.MAX_SAFE_INTEGER };\n      timeline.get(official_tick)!.push(local_queued);\n    }\n\n    for (const posts of timeline.values()) {\n      posts.sort((a, b) => a.index - b.index);\n    }\n\n    this.timeline = timeline;\n    return timeline;\n  }\n\n  compute_state_at(at_tick: number): S {\n    const initial_tick = this.initial_tick();\n\n    if (initial_tick === null) {\n      this.reset_cache();\n      return this.init;\n    }\n\n    if (at_tick < initial_tick) {\n      return this.init;\n    }\n\n    if (this.cache_start !== initial_tick) {\n      this.state_cache.length = 0;\n      this.cache_start = initial_tick;\n    }\n\n    const timeline   = this.build_timeline();\n    let state: S     = this.init;\n    let start_tick   = initial_tick;\n\n    if (this.cache_start !== null && this.state_cache.length > 0) {\n      const highest_cached_tick = this.cache_start + this.state_cache.length - 1;\n      const usable_cached_tick  = Math.min(highest_cached_tick, at_tick);\n      const cache_index         = usable_cached_tick - this.cache_start;\n      if (cache_index >= 0) {\n        state      = this.state_cache[cache_index];\n        start_tick = usable_cached_tick + 1;\n        if (start_tick > at_tick) {\n          return state;\n        }\n      }\n    }\n\n    for (let tick = start_tick; tick <= at_tick; tick++) {\n      state = this.on_tick(state);\n\n      const posts = timeline.get(tick) || [];\n      for (const post of posts) {\n        state = this.on_post(post.data, state);\n      }\n\n      if (this.cache_start !== null) {\n        const cacheIndex = tick - this.cache_start;\n        if (cacheIndex === this.state_cache.length) {\n          this.state_cache.push(state);\n        } else if (cacheIndex >= 0 && cacheIndex < this.state_cache.length) {\n          this.state_cache[cacheIndex] = state;\n        }\n      }\n    }\n\n    return state;\n  }\n\n  // Post data to the room\n  post(data: P): void {\n    const name = client.post(this.room, data);\n    const t    = this.server_time();\n\n    const local_post: Post<P> = {\n      room:        this.room,\n      index:       -1,\n      server_time: t,\n      client_time: t,\n      name,\n      data\n    };\n\n    this.local_posts.set(name, local_post);\n    this.invalidate_cache(this.official_tick(local_post));\n  }\n\n  compute_current_state(): S {\n    return this.compute_state_at(this.server_tick());\n  }\n}\n", "import { Vibi } from \"../engine/vibi\";\nimport { on_sync, ping, gen_name } from \"../network/client\";\nimport * as syncClient from \"../network/client\";\n\n// Player data tracked for each nickname\ntype Player = {\n  px: number;  // current position (tile-centered)\n  py: number;\n  tx: number;  // target tile center being walked toward\n  ty: number;\n  moving: boolean;\n  w: number;   // input state\n  a: number;\n  s: number;\n  d: number;\n};\n\n// Map of nick -> player\ntype GameState = {\n  [nick: string]: Player;\n};\n\n// Messages sent between clients\ntype GamePost =\n  | { $: \"spawn\"; nick: string; px: number; py: number }\n  | { $: \"down\"; key: \"w\" | \"a\" | \"s\" | \"d\"; player: string }\n  | { $: \"up\"; key: \"w\" | \"a\" | \"s\" | \"d\"; player: string };\n\n// Simulation + world tuning\nconst TICK_RATE         = 24;\nconst TOLERANCE         = 10; // ms of leeway when reconciling posts\nconst TILE_SIZE         = 24;\nconst WORLD_COLS        = 40;\nconst WORLD_ROWS        = 22;\nconst WORLD_WIDTH       = TILE_SIZE * WORLD_COLS;\nconst WORLD_HEIGHT      = TILE_SIZE * WORLD_ROWS;\nconst PIXELS_PER_SECOND = TILE_SIZE * 6; // tiles per second\nconst PIXELS_PER_TICK   = PIXELS_PER_SECOND / TICK_RATE;\nconst HALF_TILE         = TILE_SIZE / 2;\n\nconst initial: GameState = {};\n\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(max, value));\n}\n\nfunction tileCenterFromIndex(index: number): number {\n  return index * TILE_SIZE + HALF_TILE;\n}\n\nfunction nearestTileIndex(value: number, maxIndex: number): number {\n  const snapped = Math.round((value - HALF_TILE) / TILE_SIZE);\n  return clamp(snapped, 0, maxIndex);\n}\n\nfunction pickDirection(player: Player): \"w\" | \"a\" | \"s\" | \"d\" | null {\n  if (player.w) return \"w\";\n  if (player.a) return \"a\";\n  if (player.s) return \"s\";\n  if (player.d) return \"d\";\n  return null;\n}\n\nfunction stepToward(current: number, target: number): number {\n  const delta = target - current;\n  if (Math.abs(delta) <= PIXELS_PER_TICK) {\n    return target;\n  }\n  return current + Math.sign(delta) * PIXELS_PER_TICK;\n}\n\n// Update all players based on their pressed keys\nfunction on_tick(state: GameState): GameState {\n  const next: GameState = {};\n\n  for (const [nick, player] of Object.entries(state)) {\n    if (!player) continue;\n\n    let { px, py, tx, ty, moving } = player;\n\n    // Ensure we stick to tile centers once we reach a target\n    if (Math.abs(px - tx) < 0.001 && Math.abs(py - ty) < 0.001) {\n      px     = tx;\n      py     = ty;\n      moving = false;\n    }\n\n    // If idle, see if a direction key is pressed to start a new tile step\n    if (!moving) {\n      const dir = pickDirection(player);\n      if (dir) {\n        const tileX = nearestTileIndex(tx, WORLD_COLS - 1);\n        const tileY = nearestTileIndex(ty, WORLD_ROWS - 1);\n\n        let nextTileX = tileX;\n        let nextTileY = tileY;\n\n        switch (dir) {\n          case \"w\":\n            nextTileY = clamp(tileY - 1, 0, WORLD_ROWS - 1);\n            break;\n          case \"a\":\n            nextTileX = clamp(tileX - 1, 0, WORLD_COLS - 1);\n            break;\n          case \"s\":\n            nextTileY = clamp(tileY + 1, 0, WORLD_ROWS - 1);\n            break;\n          case \"d\":\n            nextTileX = clamp(tileX + 1, 0, WORLD_COLS - 1);\n            break;\n        }\n\n        const nextTx = tileCenterFromIndex(nextTileX);\n        const nextTy = tileCenterFromIndex(nextTileY);\n\n        if (nextTx !== tx || nextTy !== ty) {\n          tx     = nextTx;\n          ty     = nextTy;\n          moving = true;\n        }\n      }\n    }\n\n    // Continue walking toward the target tile center\n    if (moving) {\n      px = stepToward(px, tx);\n      py = stepToward(py, ty);\n\n      if (Math.abs(px - tx) < 0.001 && Math.abs(py - ty) < 0.001) {\n        px     = tx;\n        py     = ty;\n        moving = false;\n      }\n    }\n\n    next[nick] = {\n      px,\n      py,\n      tx,\n      ty,\n      moving,\n      w: player.w,\n      a: player.a,\n      s: player.s,\n      d: player.d,\n    };\n  }\n\n  return next;\n}\n\n// Apply a post (spawn or key change) to the state\nfunction on_post(post: GamePost, state: GameState): GameState {\n  switch (post.$) {\n    case \"spawn\": {\n      if (state[post.nick]) {\n        return state;\n      }\n\n      const player: Player = {\n        px: tileCenterFromIndex(nearestTileIndex(post.px, WORLD_COLS - 1)),\n        py: tileCenterFromIndex(nearestTileIndex(post.py, WORLD_ROWS - 1)),\n        tx: tileCenterFromIndex(nearestTileIndex(post.px, WORLD_COLS - 1)),\n        ty: tileCenterFromIndex(nearestTileIndex(post.py, WORLD_ROWS - 1)),\n        moving: false,\n        w: 0,\n        a: 0,\n        s: 0,\n        d: 0,\n      };\n\n      return { ...state, [post.nick]: player };\n    }\n\n    case \"down\": {\n      const target = state[post.player];\n      if (!target) return state;\n      const updated = { ...target, [post.key]: 1 } as Player;\n      return { ...state, [post.player]: updated };\n    }\n\n    case \"up\": {\n      const target = state[post.player];\n      if (!target) return state;\n      const updated = { ...target, [post.key]: 0 } as Player;\n      return { ...state, [post.player]: updated };\n    }\n  }\n\n  return state;\n}\n\n// Create a VIBI instance for this game\nexport function createGame(room: string, smooth: (past: GameState, curr: GameState) => GameState) {\n  return new Vibi<GameState, GamePost>(room, initial, on_tick, on_post, smooth, TICK_RATE, TOLERANCE);\n}\n\nfunction makeCanvas(): HTMLCanvasElement {\n  const canvas = document.createElement(\"canvas\");\n  canvas.id = \"game\";\n  canvas.style.width = \"100vw\";\n  canvas.style.height = \"100vh\";\n  canvas.style.display = \"block\";\n  canvas.style.background = \"#d9e0ea\";\n  return canvas;\n}\n\nfunction resizeCanvas(canvas: HTMLCanvasElement) {\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n}\n\nfunction drawGrid(ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement) {\n  const scaleX   = canvas.width / WORLD_WIDTH;\n  const scaleY   = canvas.height / WORLD_HEIGHT;\n  const tileW    = TILE_SIZE * scaleX;\n  const tileH    = TILE_SIZE * scaleY;\n  const toneA    = \"#c5d4df\";\n  const toneB    = \"#b7c8d5\";\n\n  for (let row = 0; row < WORLD_ROWS; row++) {\n    for (let col = 0; col < WORLD_COLS; col++) {\n      const color = (row + col) % 2 === 0 ? toneA : toneB;\n      ctx.fillStyle = color;\n      ctx.fillRect(col * tileW, row * tileH, tileW, tileH);\n    }\n  }\n\n  ctx.strokeStyle = \"#8aa0b0\";\n  ctx.lineWidth = 1;\n\n  // Vertical lines\n  for (let c = 0; c <= WORLD_COLS; c++) {\n    const x = Math.floor(c * tileW) + 0.5;\n    ctx.beginPath();\n    ctx.moveTo(x, 0);\n    ctx.lineTo(x, canvas.height);\n    ctx.stroke();\n  }\n\n  // Horizontal lines\n  for (let r = 0; r <= WORLD_ROWS; r++) {\n    const y = Math.floor(r * tileH) + 0.5;\n    ctx.beginPath();\n    ctx.moveTo(0, y);\n    ctx.lineTo(canvas.width, y);\n    ctx.stroke();\n  }\n}\n\nfunction drawPlayer(\n  ctx: CanvasRenderingContext2D,\n  canvas: HTMLCanvasElement,\n  nick: string,\n  player: Player,\n  isSelf: boolean\n): void {\n  const scaleX = canvas.width / WORLD_WIDTH;\n  const scaleY = canvas.height / WORLD_HEIGHT;\n  const spriteW = TILE_SIZE * scaleX;\n  const spriteH = TILE_SIZE * scaleY;\n  const x = player.px * scaleX - spriteW / 2;\n  const y = player.py * scaleY - spriteH / 2;\n\n  // Simple blocky sprite (head + body + shoes)\n  ctx.fillStyle = isSelf ? \"#e2574c\" : \"#3a6ea5\";\n  ctx.fillRect(x + spriteW * 0.1, y + spriteH * 0.35, spriteW * 0.8, spriteH * 0.5);\n\n  ctx.fillStyle = \"#2b2d42\";\n  ctx.fillRect(x + spriteW * 0.2, y + spriteH * 0.15, spriteW * 0.6, spriteH * 0.25);\n\n  ctx.fillStyle = \"#f4d3ae\";\n  ctx.fillRect(x + spriteW * 0.35, y + spriteH * 0.32, spriteW * 0.3, spriteH * 0.2);\n\n  ctx.fillStyle = \"#111\";\n  ctx.fillRect(x + spriteW * 0.25, y + spriteH * 0.78, spriteW * 0.2, spriteH * 0.14);\n  ctx.fillRect(x + spriteW * 0.55, y + spriteH * 0.78, spriteW * 0.2, spriteH * 0.14);\n\n  ctx.fillStyle = \"#0f172a\";\n  ctx.font = `${Math.max(10, Math.floor(spriteH * 0.35))}px monospace`;\n  ctx.textAlign = \"center\";\n  ctx.textBaseline = \"top\";\n  ctx.fillText(nick, x + spriteW / 2, y - spriteH * 0.35);\n}\n\nfunction render(\n  game: Vibi<GameState, GamePost>,\n  ctx: CanvasRenderingContext2D,\n  canvas: HTMLCanvasElement,\n  room: string,\n  nick: string\n): void {\n  drawGrid(ctx, canvas);\n\n  const state = game.compute_render_state();\n\n  for (const [id, player] of Object.entries(state)) {\n    if (!player) continue;\n    drawPlayer(ctx, canvas, id, player, id === nick);\n  }\n\n  // Simple HUD with timing info\n  ctx.fillStyle = \"#0f172a\";\n  ctx.font = \"14px monospace\";\n  ctx.textAlign = \"left\";\n  ctx.textBaseline = \"top\";\n\n  const serverTick = game.server_tick();\n  const rtt        = ping();\n  ctx.fillText(`room: ${room}`, 12, 12);\n  ctx.fillText(`tick: ${serverTick}`, 12, 30);\n  if (isFinite(rtt)) {\n    ctx.fillText(`ping: ${Math.round(rtt)} ms`, 12, 48);\n  }\n  ctx.fillText(\"WASD to move\", 12, 66);\n}\n\nlet started = false;\n\n/**\n * Entry point for client-side game logic.\n * Sets up the canvas, networking, and render loop.\n */\nexport function startGame(): void {\n  if (started) return;\n  started = true;\n\n  const container = document.getElementById(\"app\");\n  if (!container) {\n    throw new Error(\"Missing #app container\");\n  }\n\n  const canvas = makeCanvas();\n  const ctx    = canvas.getContext(\"2d\");\n  if (!ctx) throw new Error(\"Canvas 2D context unavailable\");\n  ctx.imageSmoothingEnabled = false;\n\n  container.innerHTML = \"\";\n  container.appendChild(canvas);\n  resizeCanvas(canvas);\n  window.addEventListener(\"resize\", () => resizeCanvas(canvas));\n\n  let room = prompt(\"Enter room name:\") || \"\";\n  room = room.trim() || gen_name();\n\n  const nick = prompt(\"Enter your nickname (single character):\") || \"\";\n  // if (nick.length !== 1) {\n  //   alert(\"Nickname must be exactly one character.\");\n  //   throw new Error(\"Nickname must be one character\");\n  // }\n\n  document.title = `Pokemon Grid (${room})`;\n\n  const smooth = (past: GameState, curr: GameState): GameState => {\n    if (curr[nick]) {\n      past[nick] = curr[nick];\n    }\n    return past;\n  };\n\n  const game: Vibi<GameState, GamePost> = createGame(room, smooth);\n\n  const keyStates: Record<\"w\" | \"a\" | \"s\" | \"d\", boolean> = {\n    w: false,\n    a: false,\n    s: false,\n    d: false,\n  };\n\n  on_sync(() => {\n    const spawnX = Math.floor(WORLD_WIDTH / 2);\n    const spawnY = Math.floor(WORLD_HEIGHT / 2);\n    game.post({ $: \"spawn\", nick, px: spawnX, py: spawnY });\n\n    const validKeys = new Set([\"w\", \"a\", \"s\", \"d\"]);\n\n    const handleKeyEvent = (event: KeyboardEvent) => {\n      const key = event.key.toLowerCase();\n      if (!validKeys.has(key)) return;\n\n      const isDown = event.type === \"keydown\";\n      const keyName = key as \"w\" | \"a\" | \"s\" | \"d\";\n      if (keyStates[keyName] === isDown) return;\n\n      keyStates[keyName] = isDown;\n      const action = isDown ? \"down\" : \"up\";\n      game.post({ $: action, key: keyName, player: nick });\n    };\n\n    window.addEventListener(\"keydown\", handleKeyEvent);\n    window.addEventListener(\"keyup\", handleKeyEvent);\n\n    const step = () => {\n      render(game, ctx, canvas, room, nick);\n      requestAnimationFrame(step);\n    };\n    requestAnimationFrame(step);\n  });\n}\n\nexport { Vibi, syncClient };\n\n// Auto-start when loaded in the browser bundle\nif (typeof window !== \"undefined\") {\n  startGame();\n}\n"],
  "mappings": "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",
  "names": ["ping", "on_tick", "on_post", "post", "server_time", "post"]
}
